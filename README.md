# C-DesignPatterns
学习笔记。视频来自李建忠老师的c++设计模式课程。伪代码形式表示。

## 面向对象设计原则（8种）

### 依赖倒置原则（DIP）
- 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。

### 开放封闭原则（OCP）
- 对扩展开放，对更改封闭。
- 类模块应该是可扩展的，但是不可修改。

### 单一职责原则（SRP）
- 一个类应该仅有一个引起它变化的原因。
- 变化的方向隐含着类的责任。

### Liskov替换原则（LSP）
- 子类必须能够替换它们的基类（IS-A）。
- 继承表达类型抽象。

### 接口隔离原则（ISP）
- 不应该强迫客户程序依赖它们不用的方法。
- 接口应该小而完备。

### 优先使用对象组合，而不是类继承
- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。
- 继承在某种程度上破坏了封装性，子类父类耦合度高。
- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

### 封装变化点
- 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

### 针对接口编程，而不是针对实现编程
- 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
- 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。

## 重构关键技法
- 静态->动态
- 早绑定->晚绑定
- 继承->组合
- 编译时依赖->运行时依赖
- 紧耦合->松耦合

## 从目的来看：
- 创建型（Creational）模式：将对象的部分创建工作延迟到子
类或者其他对象，从而应对需求变化为对象创建时具体类型实
现引来的冲击。
共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 结构型（Structural）模式：通过类继承或者对象组合获得更灵
活的结构，从而应对需求变化为对象的结构带来的冲击。
共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式
- 行为型（Behavioral）模式：通过类继承或者对象组合来划分
类与对象间的职责，从而应对需求变化为多个交互的对象带来
的冲击。 
共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
## 从范围来看：
- 类模式处理类与子类的静态关系。
- 对象模式处理对象间的动态关系

## 从封装变化角度对模式分类（23种）

### "组件协作"模式
现代软件专业分工之后的第一个结果是“框架与应用程序的划分”， “组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。

#### 典型模式
- Template method
- Strategy
- Observer / Event

### "单一职责"模式
在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

#### 典型模式
- decorator
- bridge

### "对象创建"模式
通过“对象创建”模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是借口抽象之后的第一步工作。

#### 典型模式
- factory method
- abstract factory
- prototype
- builder 不常用

### "对象性能"模式
面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。

#### 典型模式
- singleton
- flyweight

### "接口隔离"模式
在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。

#### 典型模式
- façade
- proxy
- adapter
- mediator 不常用

### "状态变化"模式
在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。

#### 典型模式
- state
- memento 不常用

### "数据结构"模式
常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。

#### 典型模式
- composite
- iterator 不常用
- chain of resposibility 不常用

### "行为变化"模式
在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身进行解偶，从而支持组件行为的变化，实现两者之间的松耦合。

#### 典型模式
- command 不常用
- visitor 不常用

### "领域规则"模式
在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决问题。

#### 典型模式
- interpreter 不常用